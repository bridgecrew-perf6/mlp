package cmd

import (
	"errors"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/spf13/cobra"
)

var primaryPrefix string
var alternativePrefix string
var filePath string

// interpolateCmd represents the interpolate command
var interpolateCmd = &cobra.Command{
	Use: "interpolate",
	Args: func(cmd *cobra.Command, args []string) error {
		if len(args) < 1 {
			return errors.New("no file specified")
		}
		_, err := os.Stat(args[0])
		if os.IsNotExist(err) {
			return errors.New("file " + args[0] + " does not exists")
		}

		return nil
	},
	Short: "Interpolate variables in file",
	Long:  "Interpolate the environment variables inside {{}} in file and substitutes them with the corresponding value",
	Run: func(cmd *cobra.Command, args []string) {
		filePath := args[0]
		file, err := ioutil.ReadFile(filePath)
		checkError(err)

		interpolatedFile := interpolate(file)

		f, err := os.Create("out-" + filePath)
		checkError(err)
		defer f.Close()

		_, err = f.Write(interpolatedFile)
		checkError(err)
	},
}

func init() {
	rootCmd.AddCommand(interpolateCmd)

	interpolateCmd.Flags().StringVarP(&primaryPrefix, "prefix", "p", "", "primary prefix to add when looking for envs")
	interpolateCmd.Flags().StringVarP(&alternativePrefix, "alternative-prefix", "a", "", "prefix to use when the primary prefix env does not exists")
}

type env_var struct {
	name  string
	value string
}

func interpolate(file []byte) []byte {
	envs := getVariablesToInterpolate(file)

	//exit if there are no variables to interpolate
	if len(envs) == 0 {
		os.Exit(0)
	}

	err := checkEnvs(envs)
	checkError(err)

	interpolatedFile := interpolateVariables(file, envs)

	return interpolatedFile
}

func checkError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func getVariablesToInterpolate(file_content []byte) map[string]*env_var {
	re := regexp.MustCompile("\\{\\{(.+?)\\}\\}")
	match := re.FindAllStringSubmatch(string(file_content), -1)

	vars := make(map[string]*env_var)
	for parsedVar := range match {
		varName := strings.ReplaceAll(match[parsedVar][1], " ", "")
		//keep track of the entire pattern found by the regex
		//using as key the variable name
		if _, exists := vars[varName]; !exists {
			vars[varName] = &env_var{name: match[parsedVar][0]}
		}
	}
	return vars
}

func checkEnvs(envs map[string]*env_var) error {
	for varName, _ := range envs {

		varPrefixed := primaryPrefix + "_" + varName
		varPrefixedAlternative := alternativePrefix + "_" + varName
		env := envs[varName]

		// get the escaped environment variable
		if os.Getenv(varPrefixed) != "" {
			(*env).value = strconv.Quote(os.Getenv(varPrefixed))
		} else if os.Getenv(varPrefixedAlternative) != "" {
			(*env).value = strconv.Quote(os.Getenv(varPrefixedAlternative))
		} else {
			return errors.New("environment variables " + varPrefixed + " and " + varPrefixedAlternative + " do not exist")
		}

		// discard the initial and final double quotes generated by strconv
		(*env).value = (*env).value[1 : len((*env).value)-1]
	}
	return nil
}

func interpolateVariables(file []byte, envs map[string]*env_var) []byte {
	fileString := string(file)

	for varName, _ := range envs {
		env := *envs[varName]
		fileString = strings.ReplaceAll(fileString, env.name, env.value)
	}

	return []byte(fileString)
}
